import { Injectable } from '@angular/core';
import { environment } from '../../../../../environments/environment';
import { UUID } from '../../../../@core/helpers';

declare let XMPP: any;

export const XMPP_EVENTS = {
  CONNECTED: 'connected',
  DISCONNECTED: 'disconnected',
  AUTH_SUCCESS: 'auth:success',
  AUTH_FAILED: 'auth:failed',
  SESSION_STARTED: 'session:started',
  CHAT: 'chat',
  CHAT_STATE: 'chat:state',
  MESSAGE: 'message',
  MESSAGE_SENT: 'message:sent',
  MESSAGE_ERROR: 'message:error',
  PRESENCE: 'presence',
  SUBSCRIBE: 'subscribe',
  UNSUBSCRIBE: 'unsubscribe',
  SUBSCRIBED: 'subscribed',
  UNSUBSCRIBED: 'unsubscribed',
  BLOCK: 'block',
  UNBLOCK: 'unblock',
  ROSTER_UPDATE: 'roster:update',
  RAW_OUTGOING: 'raw:outgoing',
  IQ: 'iq',
};

/**
 * chat -- The message is sent in the context of a one-to-one chat conversation. A compliant client SHOULD present the message in an interface enabling one-to-one chat between the two parties, including an appropriate conversation history.
 * error -- An error has occurred related to a previous message sent by the sender (for details regarding stanza error syntax, refer to [XMPP‑CORE]). A compliant client SHOULD present an appropriate interface informing the sender of the nature of the error.
 * groupchat -- The message is sent in the context of a multi-user chat environment (similar to that of [IRC]). A compliant client SHOULD present the message in an interface enabling many-to-many chat between the parties, including a roster of parties in the chatroom and an appropriate conversation history. Full definition of XMPP-based groupchat protocols is out of scope for this memo (for details see [JEP‑0045]).
 * headline -- The message is probably generated by an automated service that delivers or broadcasts content (news, sports, market information, RSS feeds, etc.). No reply to the message is expected, and a compliant client SHOULD present the message in an interface that appropriately differentiates the message from standalone messages, chat sessions, or groupchat sessions (e.g., by not providing the recipient with the ability to reply).
 * normal -- The message is a single message that is sent outside the context of a one-to-one conversation or groupchat, and to which it is expected that the recipient will reply. A compliant client SHOULD present the message in an interface enabling the recipient to reply, but without a conversation history.
 */
export const XMPP_MESSAGE_TYPES = {
  NORMAL: 'normal',
  CHAT: 'chat',
  HEADLINE: 'headline', // For open notification popup - Todo
  ERROR: 'error',
};

export const XMPP_MESSAGE_BODY_TYPES = {
  TEXT: 'text',
  IMAGE: 'image',
  AUTO: 'auto',
  EMOJI: 'emoji',
};

export const XMPP_MESSAGE_CHATSTATES = {
  COMPOSING: 'composing',
  ACTIVE: 'active',
  INACTIVE: 'inactive',
};

export const XMPP_PRESENCE_TYPES = {
  AVAILABLE: 'available',
  UNAVAILABLE: 'unavailable',
};

export interface XMPPUserInterface {
  jid: string;                  // 'echobot@example.com';
  password: string;             // 'hunter2';
  transport: string;            // 'websocket';
  wsURL: string;                // 'wss://example.com:5281/xmpp-websocket'
  // (or `boshURL` if using 'bosh' as the transport)
}

interface XMPPGuestInterface {
  jid: string;
  logs: Array<XMPPMessage>;
  lastLog: XMPPMessage;
  typing: boolean;
  presenceType: string;
}

export interface XMPPImageInterface {
  id: string;
  file_id: number;
  thumb_url: string;
  large_url: string;
  raw_url: string;
  filename: string;
}

interface XMPPMessageBodyInterface {
  id: string;
  from: string;
  to: string;
  team: string;
  channel: string;
  content: string;
  read: boolean;
  seen: boolean;
  status: string;
  type: string;
  timestamp: number;
}

export class XMPPMessage {
  id: string;
  jid: string;
  toJid: string;
  owner: boolean;
  body: XMPPMessageBodyInterface;
  content: string;
  files: XMPPImageInterface[];
  type: string;
  time: number;
  isLink: boolean;

  constructor(data: any, jid: string) {
    this.id = data.id;
    this.jid = data.from.bare;
    this.toJid = data.to.bare;
    this.owner = (this.jid === jid);
    this.body = JSON.parse(data.body);
    this.content = this.body.content ? this.body.content.trim() : '';
    this.type = this.body.type;
    this.time = this.body.timestamp;
    if (this.type === XMPP_MESSAGE_BODY_TYPES.EMOJI) {
      this.content = environment.FILESYSTEM.URL + '/emoji/' + this.content;
    } else if (this.type === XMPP_MESSAGE_BODY_TYPES.IMAGE) {
      this.files = [];
      _.forEach(this.content.split(';'), (image: string) => {
        this.files.push(JSON.parse(image));
      });
    } else if (this.type === XMPP_MESSAGE_BODY_TYPES.TEXT) {
      this.isLink = this.content.indexOf('http://') === 0 || this.content.indexOf('https://') === 0;
    }
  }
}

interface IXMPPClient {
  use: Function;
  on: Function;
  connect: Function;
  disco: any;
  disconnect: Function;
  enableCarbons: Function;
  getRoster: Function;
  searchHistory: Function;
  sendMessage: Function;
  sendPresence: Function;
  sendIq: Function;
  subscribe: Function;
  unsubscribe: Function;
  acceptSubscription: Function;
  denySubscription: Function;
}

export class Client {
  private errored: boolean = false;
  protected client: IXMPPClient = null;
  protected logged: boolean = false;
  protected userId: string = null;
  protected jid: string = null;
  protected guests: any = {};
  protected body: XMPPMessageBodyInterface = {
    id: null,
    content: '',
    channel: '',
    team: '',
    from: null,
    to: null,
    read: true,
    seen: false,
    status: 'new',
    type: XMPP_MESSAGE_BODY_TYPES.TEXT,
    timestamp: null,
  };

  constructor(userId: number, cb?: Function) {
    this.userId = String(userId);
    this.jid = this.userId + '@' + environment.XMPP.HOST;
    const user: XMPPUserInterface = {
      jid: this.jid,
      password: environment.XMPP.PASSWORD,
      wsURL: environment.XMPP.WSURL,
      transport: 'websocket',
    };

    this.client = XMPP.createClient(user);

    // Events
    this.client.on('*', (name, data) => {
      if (name === 'streamError') this.errored = true;
      if (cb instanceof Function) cb(name, data);
    });
    this.client.on(XMPP_EVENTS.CONNECTED, () => {
      console.info(XMPP_EVENTS.CONNECTED + ': ' + this.jid);
    });
    this.client.on(XMPP_EVENTS.AUTH_SUCCESS, () => {
      this.logged = true;
    });
    this.client.on(XMPP_EVENTS.AUTH_FAILED, () => {
      this.logged = false;
    });
    this.client.on(XMPP_EVENTS.SESSION_STARTED, () => {
      // Fetch Rosters
      // this.fetchLatestRosters();
      // this.client.updateCaps();
      // Message Syncing
      this.client.sendPresence({caps: this.client.disco.caps});
      this.client.enableCarbons((err) => {
        if (err) console.log('Server does not support carbons');
      });
    });

    // Connect
    this.client.connect();

    // Reconnect
    this.client.on(XMPP_EVENTS.DISCONNECTED, () => {
      console.log(XMPP_EVENTS.DISCONNECTED + ': ' + this.jid);
      if (this.logged && !this.errored) {
        this.client.connect();
      }
    });

    // Add Last Extension
    // <iq type='get' id='ryryryryrr84848h' to='2@onllearn.vn'><query xmlns='jabber:iq:last'/></iq>
    this.client.use(((client, JXT) => {
      JXT.extendIQ(JXT.define({
        name: 'lastActivity',
        element: 'query',
        namespace: 'jabber:iq:last',
        fields: {
          seconds: JXT.utils.numberAttribute('seconds'),
        },
      }));
    }).bind(this));
  }

  destroy(): void {
    if (this.client) {
      this.client.disconnect();
      this.client = null;
      this.logged = false;
      this.guests = {};
    }
  }

  addListener(cb: Function) {
    this.client.on('*', (name, data) => {
      cb(name, data);
    });

    return this;
  }

  getGuest(userId: string): XMPPGuestInterface {
    return this.guests[userId];
  }

  getOnline(jid: string, cb?: Function) {
    this.client.sendIq({to: jid, type: 'get', lastActivity: true}, cb).then((res: any) => {
      console.log(res.lastActivity);
    }, (err: any) => {
      console.log(err.error.text);
    });
  }

  // Same as updateAvailableByPresence fn
  setOnline(data: any) {
    if (data.lastActivity && typeof data.lastActivity.seconds !== 'undefined') {
      const guest: XMPPGuestInterface = this.getGuest(data.from.local);
      if (guest) {
        console.log(data.lastActivity.seconds);
        guest.presenceType = data.lastActivity.seconds === 0 ? XMPP_PRESENCE_TYPES.AVAILABLE : XMPP_PRESENCE_TYPES.UNAVAILABLE;
      }
    }
  }

  changePresence(data: any) {
    const guest: XMPPGuestInterface = this.getGuest(data.from.local);
    if (guest) {
      setTimeout(() => this.getOnline(guest.jid), 1000);
    }
  }

  addUser(userId): XMPPGuestInterface {
    const jid = String(userId) + '@' + environment.XMPP.HOST;
    const guest: XMPPGuestInterface = {jid: jid, logs: [], lastLog: null, typing: true, presenceType: XMPP_PRESENCE_TYPES.UNAVAILABLE};
    this.guests[userId] = guest;
    this.client.subscribe(jid);
    this.client.acceptSubscription(jid);
    // Fetch Histories
    this.client.searchHistory({'with': jid});
    // Get Online
    setTimeout(() => this.getOnline(jid), 1000);

    return guest;
  }

  removeUser(userId): void {
    const jid = String(userId) + '@' + environment.XMPP.HOST;
    if (this.guests[userId]) {
      delete this.guests[userId];
      // this.client.unsubscribe(jid);
      this.client.denySubscription(jid);
    }
  }

  appendLogs(userId: string, data: any): boolean {
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (!guest) return false;
    const log: XMPPMessage = _.find(guest.logs, {id: data.id});
    if (!log) {
      const lastLog = new XMPPMessage(data, this.jid);
      if ((lastLog.jid === this.jid || lastLog.jid === guest.jid) && (lastLog.toJid === this.jid || lastLog.toJid === guest.jid)) {
        guest.lastLog = lastLog;
        guest.logs.push(guest.lastLog);
        guest.logs.sort((a: XMPPMessage, b: XMPPMessage) => {
          if (a.time < b.time) {
            return -1;
          } else if (a.time > b.time) {
            return 1;
          } else {
            return 0;
          }
        });
        return true;
      }
    }

    return false;
  }

  getLogs(userId: string): XMPPMessage[] {
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (!guest) return [];
    return guest.logs;
  }

  getLastLog(userId: string): XMPPMessage {
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (!guest) return null;
    return guest.lastLog;
  }

  sendMessage(userId: string, content: string, type?: string): any {
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (!guest) return false;
    if (!this.logged || !content) return false;

    const body: XMPPMessageBodyInterface = _.cloneDeep(this.body);
    body.id = UUID.UUID();
    body.from = this.userId;
    body.to = userId;
    body.content = content.trim();
    body.type = type ? type : XMPP_MESSAGE_BODY_TYPES.TEXT;
    body.timestamp = new Date().getTime();
    const lastLog = this.getLastLog(userId);
    if (lastLog) {
      body.team = lastLog.body.team;
      body.channel = lastLog.body.channel;
    }
    if (!body.channel && environment.production) {
      alert('Disconnect!');
    } else {
      const message: { from: string, to: string, body: string } = {from: this.jid, to: guest.jid, body: JSON.stringify(body)};

      // Send message after reformat
      this.client.sendMessage(message);
      // console.log('sendMessage', content, message);
    }

    return body;
  }

  hasTyping(data: any): boolean {
    const typing = this.jid !== data.from.bare;

    const guest: XMPPGuestInterface = this.getGuest(data.from.local);
    if (guest) guest.typing = typing;

    return typing;
  }

  sendTyping(userId: string, enable?: boolean): boolean {
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (!guest) return false;
    if (!this.logged) return false;

    if (enable === true) {
      this.client.sendMessage({to: guest.jid, from: this.jid, chatState: XMPP_MESSAGE_CHATSTATES.COMPOSING});
    } else {
      this.client.sendMessage({to: guest.jid, from: this.jid, chatState: XMPP_MESSAGE_CHATSTATES.INACTIVE});
    }

    return true;
  }

  updateAvailableByPresence(userId: string, data: any): boolean {
    let online = false;
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (guest && guest.jid === data.from.bare) {
      online = data.type === XMPP_PRESENCE_TYPES.AVAILABLE;
      console.log(data.type);
      guest.presenceType = online ? XMPP_PRESENCE_TYPES.AVAILABLE : XMPP_PRESENCE_TYPES.UNAVAILABLE;
    }
    return online;
  }

  hasAvailable(userId: string): boolean {
    const guest: XMPPGuestInterface = this.getGuest(userId);
    if (guest) {
      return guest.presenceType === XMPP_PRESENCE_TYPES.AVAILABLE;
    }
    return false;
  }

  /*fetchLatestRosters() {
    this.rosters = [];
    this.client.getRoster((error, response) => {
      if (response.roster.items) {
        this.rosters = response.roster.items;
      }
      this.isFetchedRoster = true;
    });
  }

  fetchHistoryByJid(jid) {
    return new Promise((resolve, reject) => {
      this.client.searchHistory({'with': jid}, (error, response) => {
        if (error) {
          reject(error);
        } else {
          resolve(response.mamResult.items.map(item => new XMPPMessage(item.forwarded.message, this.jid)));
        }
      });
    });
  }

  getHistories() {
    const allPromises = [];

    allPromises.push(this.fetchHistoryByJid(this.jid));
    allPromises.push(this.fetchHistoryByJid(this.toJid));

    return new Promise((resolve, reject) => {
      Promise.all(allPromises).then(
        (response) => {
          let list = [];
          _.each(response, (items) => {
            list = list.concat(items);
          });
          list.sort((a: XMPPMessage, b: XMPPMessage) => {
            if (a.time < b.time) {
              return -1;
            } else if (a.time > b.time) {
              return 1;
            } else {
              return 0;
            }
          });
          resolve(list);
        },
        (error) => reject(error),
      );
    });
  }*/
}

@Injectable()
export class MessengerService {
  client: Client;

  constructor() {
  }

  login(userId: number, cb?: Function): Client {
    this.client = new Client(userId, cb);

    return this.client;
  }
}
